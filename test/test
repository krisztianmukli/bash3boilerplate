#!/usr/bin/env bash
#===============================================================================
# Test BASH3 Boilerplate by krisztianmukli (test)
# v2.0.0- 2018-05-23
# Licensed under the MIT license
#
# Long description of script
# 
# Copyright (c) 2018 KrisztiÃ¡n Mukli
# Copyright (c) 2013-2018 Kevin van Zonneveld and contributors
# https://github.com/krisztianmukli/bash3boilerplate
#
# Notes
#-------------------------------------------------------------------------------
# Quickstart
# Setup information
# Changelog
# ToDo
# Known bugs
#
# Based on BASH4 Boilerplate 20170818-dev and BASH3 Boilerplate v2.3.0
#===============================================================================
# Init section
#===============================================================================
# Allowing aliases
shopt -s expand_aliases
# Exit on error 
set -o errexit 
# Exit on error inside any functions or subshells
set -o errtrace
 # Do not allow use of undefined vars. Use ${VAR:-} to use an undefined VAR
set -o nounset 
# Catch the error when mysqldump fails (but gzip succeeds) in `mysqldump |gzip`
set -o pipefail 
# Turn on traces, useful while debugging but commented out by default
#set -o xtrace

#===============================================================================
# Globals section
#===============================================================================

#-------------------------------------------------------------------------------
# Environment variables
#-------------------------------------------------------------------------------
if [[ "${BASH_SOURCE[0]}" != "${0}" ]] ; then
  __test_srcd=1
  if [[ "${__test_usage+x}" ]]; then
    [[ "${BASH_SOURCE[1]}" = "${0}" ]] && __test_srcd=0
    __test_external_usage=1
    __test_tmp_surce_idx=1
  fi 
else
  __test_srcd=0
  [[ "${__test_usage+x}" ]] && unset -v __test_usage
  [[ "${__test_helptext+x}" ]] && unset -v __test_helptext
fi
__test_dir="$(cd "$(dirname "${BASH_SOURCE[${__test_tmp_source_idx:-0}]}")" && pwd)"
__test_file="${__test_dir}/$(basename "${BASH_SOURCE[${__test_tmp_source_idx:-0}]}")"
__test_base="$(basename "${__test_file}" .sh)"

LOG_LEVEL="${LOG_LEVEL:-6}" # 7 = debug -> 0 = emergency
NO_COLOR="${NO_COLOR:-}"    # true = disable color. otherwise autodetected

#-------------------------------------------------------------------------------
# Sourced files 
#-------------------------------------------------------------------------------
export PATH="${__test_dir}/lib:${HOME}/.local/share/${__test_base}:$PATH"
source log.sh

#-------------------------------------------------------------------------------
# Usage 
#-------------------------------------------------------------------------------
[[ "${__test_usage+x}" ]] || __test_usage="-t --test  [arg] Running the specified test-case
  -v --verbose     Enable verbose mode, print script as it is executed
  -d --debug       Enables debug mode
  -h --help        This page"

[[ "${__test_helptext+x}" ]] || __test_helptext="Acceptance test-script for BASH3 Boilerplate."
__test_defaulttext="Default"
__test_requiredtext="Required"

#===============================================================================
# Functions section
#===============================================================================
function help () {
  echo "" 1>&2
  echo " ${*}" 1>&2
  echo "" 1>&2
  echo "  ${__test_usage:-No usage available}" 1>&2
  echo "" 1>&2

  if [[ "${__test_helptext:-}" ]]; then
    echo " ${__test_helptext}" 1>&2
    echo "" 1>&2
  fi

  exit 1
}

running_testcase(){
  local file="${1}"

  if [[ "${file:0-3}" != ".sh" ]]; then
    file="${file}.sh"
  fi

  if [[ -e "${__test_dir}/${file}" && -x "${__test_dir}/${file}" ]]; then	  
    info "${file} started"
    time "${__test_dir}/${file}"
  else
    warning "No such test case: ${1}!"
  fi
}

function main() {
# Starting testcases
  if [[ -z "${__test_arg_t}" ]]; then
    warning "No specified testcase, running all!"
    files=(*)
  else
    files=( ${__test_arg_t//,/ } )
  fi

  for file in "${files[@]}";do
    if [[ "${file}" != "${__test_base}" && "${file}" != "testcase-template.sh" ]]; then 
      running_testcase "${file}"
    fi
  done
}

#===============================================================================
# Main section
#===============================================================================

#-------------------------------------------------------------------------------
# Parse usage string
#-------------------------------------------------------------------------------
while read -r __test_tmp_line; do
  if [[ "${__test_tmp_line}" =~ ^- ]]; then
    # fetch single character version of option string
    __test_tmp_opt="${__test_tmp_line%% *}"
    __test_tmp_opt="${__test_tmp_opt:1}"

    # fetch long version if present
    __test_tmp_long_opt=""

    if [[ "${__test_tmp_line}" = *"--"* ]]; then
      __test_tmp_long_opt="${__test_tmp_line#*--}"
      __test_tmp_long_opt="${__test_tmp_long_opt%% *}"
    fi

    # map opt long name to+from opt short name
    printf -v "__test_tmp_opt_long2short_${__test_tmp_long_opt//-/_}" '%s' "${__test_tmp_opt}"
    printf -v "__test_tmp_opt_short2long_${__test_tmp_opt}" '%s' "${__test_tmp_long_opt//-/_}"

    # check if option takes an argument
    if [[ "${__test_tmp_line}" =~ \[.*\] ]]; then
      __test_tmp_opt="${__test_tmp_opt}:" # add : if opt has arg
      __test_tmp_init=""  # it has an arg. init with ""
      printf -v "__test_tmp_has_arg_${__test_tmp_opt:0:1}" '%s' "1"
    elif [[ "${__test_tmp_line}" =~ \{.*\} ]]; then
      __test_tmp_opt="${__test_tmp_opt}:" # add : if opt has arg
      __test_tmp_init=""  # it has an arg. init with ""
      # remember that this option requires an argument
      printf -v "__test_tmp_has_arg_${__test_tmp_opt:0:1}" '%s' "2"
    else
      __test_tmp_init="0" # it's a flag. init with 0
      printf -v "__test_tmp_has_arg_${__test_tmp_opt:0:1}" '%s' "0"
    fi
    __test_tmp_opts="${__test_tmp_opts:-}${__test_tmp_opt}"
  fi

  [[ "${__test_tmp_opt:-}" ]] || continue

  if [[ "${__test_tmp_line}" =~ ^"${__test_defaulttext}"= ]] || [[ "${__test_tmp_line}" =~ \.\ *"${__test_defaulttext}"= ]]; then
    # ignore default value if option does not have an argument
    __test_tmp_varname="__test_tmp_has_arg_${__test_tmp_opt:0:1}"

    if [[ "${!__test_tmp_varname}" != "0" ]]; then
      __test_tmp_init="${__test_tmp_line##*${__test_defaulttext}=}"
      __test_tmp_re='^"(.*)"$'
      if [[ "${__test_tmp_init}" =~ ${__test_tmp_re} ]]; then
        __test_tmp_init="${BASH_REMATCH[1]}"
      else
        __test_tmp_re="^'(.*)'"
        if [[ "${__test_tmp_init}" =~ ${__test_tmp_re} ]]; then
          __test_tmp_init="${BASH_REMATCH[1]}"
        fi
      fi
    fi
  fi

  if [[ "${__test_tmp_line}" =~ ^"${__test_requiredtext}"\. ]] || [[ "${__test_tmp_line}" =~ \.\ *"${__test_requiredtext}"\. ]]; then
    # remember that this option requires an argument
    printf -v "__test_tmp_has_arg_${__test_tmp_opt:0:1}" '%s' "2"
  fi

  printf -v "__test_arg_${__test_tmp_opt:0:1}" '%s' "${__test_tmp_init}"
done <<< "${__test_usage:-}"

#-------------------------------------------------------------------------------
# Parse command-line arguments
#-------------------------------------------------------------------------------
# run getopts only if options were specified in __usage
if [[ "${__test_tmp_opts:-}" ]]; then
  # Allow long options like --this
  __test_tmp_opts="${__test_tmp_opts}-:"

  # Reset in case getopts has been used previously in the shell.
  OPTIND=1

  # start parsing command line
  set +o nounset # unexpected arguments will cause unbound variables
                 # to be dereferenced
  # Overwrite $arg_<flag> defaults with the actual CLI options
  while getopts "${__test_tmp_opts}" __test_tmp_opt; do
    [[ "${__test_tmp_opt}" = "?" ]] && help "Invalid use of script: ${*} "

    if [[ "${__test_tmp_opt}" = "-" ]]; then
      # OPTARG is long-option-name or long-option=value
      if [[ "${OPTARG}" =~ .*=.* ]]; then
        # --key=value format
        __test_tmp_long_opt=${OPTARG/=*/}
        # Set opt to the short option corresponding to the long option
        __test_tmp_varname="__test_tmp_opt_long2short_${__test_tmp_long_opt//-/_}"
        printf -v "__test_tmp_opt" '%s' "${!__test_tmp_varname}"
        OPTARG=${OPTARG#*=}
      else
        # --key value format
        # Map long name to short version of option
        __test_tmp_varname="__test_tmp_opt_long2short_${OPTARG//-/_}"
        printf -v "__test_tmp_opt" '%s' "${!__test_tmp_varname}"
        # Only assign OPTARG if option takes an argument
        __test_tmp_varname="__test_tmp_has_arg_${__test_tmp_opt}"
        printf -v "OPTARG" '%s' "${@:OPTIND:${!__test_tmp_varname}}"
        # shift over the argument if argument is expected
        ((OPTIND+=__test_tmp_has_arg_${__test_tmp_opt}))
      fi
      # we have set opt/OPTARG to the short value and the argument as OPTARG if it exists
    fi
    __test_tmp_varname="__test_arg_${__test_tmp_opt:0:1}"
    __test_tmp_default="${!__test_tmp_varname}"

    __test_tmp_value="${OPTARG}"
    if [[ -z "${OPTARG}" ]]; then
      __test_tmp_value=$((__test_tmp_default + 1))
    fi

    printf -v "${__test_tmp_varname}" '%s' "${__test_tmp_value}"
    debug "cli arg ${__test_tmp_varname} = (${__test_tmp_default}) -> ${!__test_tmp_varname}"
  done
  set -o nounset # no more unbound variable references expected

  shift $((OPTIND-1))

  if [[ "${1:-}" = "--" ]] ; then
    shift
  fi
fi
#-------------------------------------------------------------------------------
# Validate required option arguments
#-------------------------------------------------------------------------------
for __test_tmp_varname in ${!__test_tmp_has_arg_*}; do
  # validate only options which required an argument
  [[ "${!__test_tmp_varname}" = "2" ]] || continue

  __test_tmp_opt_short="${__test_tmp_varname##*_}"
  __test_tmp_varname="__test_arg_${__test_tmp_opt_short}"
  [[ "${!__test_tmp_varname}" ]] && continue

  __test_tmp_varname="__test_tmp_opt_short2long_${__test_tmp_opt_short}"
  printf -v "__test_tmp_opt_long" '%s' "${!__test_tmp_varname}"
  [[ "${__test_tmp_opt_long:-}" ]] && __test_tmp_opt_long=" (--${__test_tmp_opt_long//_/-})"

  help "Option -${__test_tmp_opt_short}${__test_tmp_opt_long:-} requires an argument"
done

#-------------------------------------------------------------------------------
# Cleanup temporary variables 
#-------------------------------------------------------------------------------
for __tmp_varname in ${!__test_tmp_*}; do
  unset -v "${__tmp_varname}"
done

unset -v __tmp_varname

#-------------------------------------------------------------------------------
# Externally supplied __test_usage. Nothing else to do here
#-------------------------------------------------------------------------------
if [[ "${__test_external_usage:-}" == 1 ]]; then
  unset -v __test_external_usage
  return
fi

#-------------------------------------------------------------------------------
# Call internal functions
#-------------------------------------------------------------------------------
# debug mode
if [[ "${__test_arg_d:?}" = "1" ]]; then
  set -o xtrace
  LOG_LEVEL="7"
  # Enable error backtracing
  trap '__test_err_report "${FUNCNAME:-.}" ${LINENO}' ERR
fi

# verbose mode
if [[ "${__test_arg_v:?}" = "1" ]]; then
  set -o verbose
fi

# help mode
if [[ "${__test_arg_h:?}" = "1" ]]; then
  # Help exists with code 1
  help "Help using ${0}"
fi


#-------------------------------------------------------------------------------
# Validate required arguments
#-------------------------------------------------------------------------------
[[ "${LOG_LEVEL:-}" ]] || emergency "Cannot continue without LOG_LEVEL. "


#-------------------------------------------------------------------------------
# Runtime
#-------------------------------------------------------------------------------
if [[ "${__test_srcd:-}" == 0 ]]; then
  main
fi

#===============================================================================
# END OF FILE
#===============================================================================
