#!/usr/bin/env bash
#===============================================================================
# Standalone script installer (script_install)
# Licensed under the MIT license
#
# This file can install bash-script and it's dependencies from a specified
# folder, using install.ini file. 
# It is part of BASH3 Boilerplate by krisztianmukli project.
# 
# Copyright (c) 2018 KrisztiÃ¡n Mukli
# https://www.github.com/krisztianmukli/bash3boilerplate
#
# Notes
#-------------------------------------------------------------------------------
# Quickstart
#
#   script_install -s sourcedir [-t targetdir | -c]
#
# Setup information
# Changelog
# ToDo
# Known bugs and limitations
#
# * When targetfile unwritable and cp ask 'try anyway?' and user choose No, 
#   it will exit 0, and script_install say installation was succesful.
# * Preinstall and postinstall script must be locate in source directory
#
# Based on BASH3 Boilerplate by krisztianmukli v1.0.0
#===============================================================================
# Init section
#===============================================================================
# Exit on error 
set -o errexit 
# Exit on error inside any functions or subshells
set -o errtrace
# Do not allow use of undefined vars. Use ${VAR:-} to use an undefined VAR
set -o nounset 
# Catch the error when mysqldump fails (but gzip succeeds) in `mysqldump |gzip`
set -o pipefail 
# Turn on traces, useful while debugging but commented out by default
#set -o xtrace

#===============================================================================
# Globals section
#===============================================================================

#-------------------------------------------------------------------------------
# Environment variables
#-------------------------------------------------------------------------------
if [[ "${BASH_SOURCE[0]}" != "${0}" ]] ; then
  __si_srcd=1
  if [[ "${BASH_SOURCE[1]+x}" ]]; then
    [[ "${BASH_SOURCE[1]}" = "${0}" ]] && __si_srcd=0
    __si_tmp_source_idx=1
  fi
  [[ "${__si_usage+x}" ]] && __si_external_usage=1
else
  __si_srcd=0
  [[ "${__si_usage+x}" ]] && unset -v __si_usage
  [[ "${__si_helptext+x}" ]] && unset -v __si_helptext
fi
__si_dir="$(cd "$(dirname "${BASH_SOURCE[${__si_tmp_source_idx:-0}]}")" && pwd)"
__si_file="${__si_dir}/$(basename "${BASH_SOURCE[${__si_tmp_source_idx:-0}]}")"
__si_base="$(basename "${__si_file}" .sh)"
__si_user_home="$([[ "${SUDO_USER+x}" ]] && getent passwd "${SUDO_USER}" | cut -d: -f6 || echo "$HOME")"
__si_act_dir=$(pwd)

LOG_LEVEL="${LOG_LEVEL:-6}" # 7 = debug -> 0 = emergency
LOG_TIMEZONE="${LOG_TIMEZONE:-1}" # 0 = UTC, otherwise local
NO_COLOR="${NO_COLOR:-}"    # true = disable color. otherwise autodetected

#-------------------------------------------------------------------------------
# Sourced files
#-------------------------------------------------------------------------------
export PATH="${__si_dir}:${__si_dir}/lib:$PATH"
source log.sh || (echo "Fatal error: Cannot find log.sh!"; exit 1)
source os_detection.sh || (echo "Fatal error: Cannot find os_detection.sh!"; exit 1)
source display_info.sh || (echo "Fatal error: Cannot find display_info.sh!"; exit 1)
source ini_val.sh || (echo "Fatal error: Cannot find ini_val.sh!"; exit 1)
source ask.sh || (echo "Fatal error: Cannot find ask.sh!"; exit 1)
source gettext.sh || (echo "Fatal error: Cannot find gettext.sh!"; exit 1)

#-------------------------------------------------------------------------------
# Localization
#-------------------------------------------------------------------------------
__si_localepath=( "${__si_dir}/locale" "${__si_user_home}/.local/share/locale" "/usr/local/share/locale" "/usr/share/locale" )
  for folder in "${__si_localepath[@]}"; do
    if [[ -d "${folder}" ]]; then
      count=$(find "${folder}" -name "${__si_base}.mo" | wc -l )
      if [[ $count -gt 0 ]]; then
        export TEXTDOMAINDIR="${folder}"
        break
      fi
    fi
  done
export TEXTDOMAIN="${__si_base}"

#-------------------------------------------------------------------------------
# Usage 
#-------------------------------------------------------------------------------
[[ "${__si_usage+x}" ]] || __si_usage="$(eval_gettext "Available arguments:

  -c --check-dependencies  Check dependencies of specified script
  -d --debug               Enables debug mode
  -f --force               Forcing commands (e.g. overwrite existing files)
  -h --help                This page
  -i --ini [inifile]       Ini-file using the installation. If not set, installer use [sourcedir]/install.ini
  -m --mode [mode]         Install mode. Default=\"auto\"
                           Possible values:
			   * 'auto' - default option, installer will try to use ini-file, switch to simple mode if it is not accessible
                           * 'simple' - installer don't use .ini-file, preinst, postinst script won't run,
			   it will not checking and installing dependencies
			   * 'configured' - installer is reading preinst, postinst scripts from .ini-file
			   checking and installing missing dependencies and third party scripts, failed the install, when ini file not accessible

  -n --no-color            Disable color output
  -s --source [sourcedir]  Source dir of script. Default=\"\$__si_act_dir\"
  -t --target [targetdir]  Target directory. Default=system-wide
                           You can use following abbreviations, or specify explicit target:
                           * 'sys', 'system' or 'system-wide' for /usr/local/bin (/usr/local/share/locale for localization)
                           * 'usr', 'user' or 'user-wide' for ~/.local/bin (~/.local/share/locale for localization)
                           If specify explicit targetdir, script libraries and locale will install to that folder.
                           Optional, if not specified, script assumes system-wide installation, 
                           fallback to user-wide if user hasn't root permission.

  -v                       Enable verbose mode, print script as it is executed
  -V --version             Display version and license information")"

[[ "${__si_helptext+x}" ]] || __si_helptext="$(gettext "This command can install bash-script and it's dependencies from a specified
 folder, using install.ini file. 
 It is part of BASH3 Boilerplate by krisztianmukli project.")"
__si_defaulttext="$(gettext "Default")"
__si_requiredtext="$(gettext "Required")"
__si_name="$(gettext "Standalone script installer")"
__si_version="v1.0.0"
__si_license="$(gettext "Licensed under the MIT license")"

#===============================================================================
# Functions section
#===============================================================================
function check_dir() {
local path="${1:-}"
local mode="${2:-w}"

  debug "check_dir $@"
  pathchk -P "${path}" || emergency "$(eval_gettext "Installation unsuccessful: unsupported foldername (\$path)")"
  [[ "${path}" =~ [^\x00-\x1F]* ]] || emergency "$(eval_gettext "Installation unsuccessful: Unsupported characters in foldername (\$path)")"

  if [[ ! -e "${path}" ]]; then
    if [[ "${mode}" = "w" ]]; then (mkdir "${path}" 2>/dev/null || emergency "$(eval_gettext "Installation unsuccessful: can not create \${path}")");
    elif [[ "$mode" = "r" ]]; then emergency "$(eval_gettext "Installation unsuccessful: \${path} is not exists!")";
    elif [[ "${mode}" = "e" ]]; then return;
    fi
  fi

  [[ ! -d "${path}" ]] && emergency "$(eval_gettext "Installation unsuccessful: \${path} is not a directory")"
  [[ ! -r "${path}" ]] && emergency "$(eval_gettext "Installation unsuccessful: \${path} is not readable!")"
  [[ "${mode}" = "w" ]] && [[ ! -w "${path}" ]] && emergency "$(eval_gettext "Installation unsuccessful: \${path} is not writable")"
  debug "check_dir OK"
}

function check_inifile() {
local path="${1:-}"
local mode="${2:-auto}"

  debug "check_inifile $@"
  if [[ "${mode}" =~ ^auto$ ]]; then
    pathchk -P "${inifile}" 2>/dev/null || (notice "$(eval_gettext "Unsupported filename (\$inifile)")"; echo "simple")
    [[ "${path}" =~ [^\x00-\x1F]* ]] || (notice "$(eval_gettext "Installation unsuccessful: Unsupported characters in filename (\$path)")"; echo "simple")
    [[ ! -e "${inifile}" ]] && (notice "$(eval_gettext "\${inifile} is not exists!")"; echo "simple")
    [[ ! -f "${inifile}" ]] && (notice "$(eval_gettext "\${inifile} is not a file!")"; echo "simple")
    [[ ! -r "${inifile}" ]] && (notice "$(eval_gettext "\${inifile} is not readable!")"; echo "simple")
  elif [[ "${mode}" =~ ^configured$ ]]; then
    pathchk -P "${inifile}" 2>/dev/null || emergency "$(eval_gettext "Unsupported filename (\$inifile)")";
    [[ "${path}" =~ [^\x00-\x1F]* ]] || emergency "$(eval_gettext "Installation unsuccessful: Unsupported characters in filename (\$path)")"
    [[ ! -e "${inifile}" ]] && emergency "$(eval_gettext "\${inifile} is not exists!")"
    [[ ! -f "${inifile}" ]] && emergency "$(eval_gettext "\${inifile} is not a file!")"
    [[ ! -r "${inifile}" ]] && emergency "$(eval_gettext "\${inifile} is not readable!")"
  fi

  debug "check_inifile OK"
  echo "configured"
}

function check_files() {
local files="${1:-}"
local path="${2:-}"
local mode="${3:-}"
local filepath

  debug "check_files $@"
  for file in ${files}; do
    filepath="${path}/${file}"
    pathchk -P "${filepath}" 2>/dev/null || emergency "$(eval_gettext "Installation unsuccessful: unsupported filename (\$filepath)")"
    [[ "${filepath}" =~ [^\x00-\x1F]* ]] || emergency "$(eval_gettext "Installation unsuccessful: Unsupported characters in filename (\$filepath)")"
    #if [[ "${filepath}" = /* ]] || [[ "${filepath}" = ../* ]] || [[ "${filepath}" = */.. ]] || [[ "${filepath}" = */. ]] || [[ "${filepath}" = */../* ]] || [[ "${filepath}" = */./* ]]; then 
    if [[ "${filepath}" = ../* ]] || [[ "${filepath}" = */.. ]] || [[ "${filepath}" = */. ]] || [[ "${filepath}" = */../* ]] || [[ "${filepath}" = */./* ]]; then 
      emergency "$(eval_gettext "Installation unsuccessful: invalid filepath (\$filepath)")"
    fi
    [[ ! -e "${filepath}" ]] && emergency "$(eval_gettext "Installation unsuccessful: file not found (\$filepath)")"
    [[ ! -f "${filepath}" ]] && emergency "$(eval_gettext "Installation unsuccessful: \$filepath is not a file")"
    [[ ! -r "${filepath}" ]] && emergency "$(eval_gettext "Installation unsuccessful: file not accessible (\$filepath)")"
    [[ "${mode}" = "x" ]] && [[ ! -x "${filepath}" ]] && emergency "$(eval_gettext "Installation unsuccessful: file has not executable permissions (\$filepath)")"
  done

  debug "check_files OK"
}

function run_scripts(){
local scripts=${1:-}
local path=${2:-.}

  debug "run_scripts $@"
  for script in ${scripts}; do
    "${path}/${script}" || emergency "$(eval_gettext "Installation unsuccessful: running \${path}/\${script} was failed")"
  done
}
function install_dependencies(){
local missingpkgs="${1:-}"
local force=${2:-0}
local result

  debug "$(gettext "Starting package-installation")"
  set +o errexit # Not exit on error, neccesary for logging package-management return codes
  install_pkgs "${missingpkgs}" "${force}" 2>&1 | while read line; do info "${line}"; done;
  result=$?
  set -o errexit # Exit on error
  case $result in
    0)
      info "$(eval_gettext "Installation of following dependencies was succesful: \${missingpkgs}")"
      return 0
      ;;
    1)
      warning "$(gettext "No valid packages")"
      return 1
      ;;
    2)
      error "$(gettext "You need higher privileges for installing packages!")"
      return 1
      ;;
    3)
      error "$(eval_gettext "For installing following packages in macOS, you must use Homebrew or Macports: \${missingpkgs}")"
      return 1
      ;;
    4)
      error "$(eval_gettext "Install the following packages from shell in cygwin, must be use apt-cyg, or install them with Cygwin setup.exe: \${missingpkgs}")"
      return 1
      ;;
    255)
      error "$(eval_gettext "Unknown or unsupported operating system, cannot install following packages: \${missingpkgs}")"
      return 1
      ;;
    *)
      error "$(eval_gettext "Unknown error during installing packages! Error code: \$result")"
      return 1
      ;;
  esac
  debug "$(gettext "Finished the package-installation")"
}
function install_files(){
local files="${1:-}"
local sourcedir="${2:-}"
local targetdir="${3:-}"

  for file in ${files}; do
    install --compare "${sourcedir}/${file}" --target-directory="${targetdir}" || emergency "$(gettext "Installation unsuccessful: there was an error during install files")"
  done
}

#-------------------------------------------------------------------------------
# Main function: Determine targetdir based on OS-type and ini-values, then call
# install_files and edit_profile methods
# Arguments:
#   None
# Returns:
#   exit 1, if unsupported OS detected
#-------------------------------------------------------------------------------
#...............................................................................
# Overview of script install process
#
# 00. Check supported OS, otherwise exit
# 01. Set local variables, based on arguments (sourcedir, inifile, force)
# 02. Check sourcedir, sourcedir/lib and sourcedir/locale is exists and readable, otherwise exit
# 03. Check inifile is exist and readable, if not goto fallback-mode (fallback-mode: copy sh-files, lib and locale folder to targetdir, no preinst, postinst, dependencychecking, etc.)
# 04. Set targetdir and localedir (targetdir, profiletext, localedir)
# 05. Check targetdir, targetdir/lib, localedir is exists and writable, if not trying to create them, if fails exit !! as USER in user install
# 06. Read initial values based on ini-file (scripts, preinsts, postinst, payloads, dependencies, thirdparties)
# 07. Check inital values contains only allowed characters, otherwise exit
# 08. Run preinstall scripts, if return non-zero, exit !! May need ROOT
# 09. Install missing dependencies, if return non-zero, exit !! ROOT
# 10. Run thirdparty dependencies, if return non-zero, exit !! May need ROOT
# 11. Copy scripts to targetdir, if fails exit !! as USER in user install
# 12. Copy locale to localetargetdir, if fails exit !! as USER in user install
# 13. Copy libraries to targetdir/lib, if fails exit !! as USER in user install
# 14. Copy payloads to targetdir, if fails exit !! as USER in user install
# 15. Run postinstall scripts, if return non-zero, exit !! May need ROOT
# 16. Edit ~/.profile file if need 

# run method as other user: https://stackoverflow.com/questions/9448920/how-can-i-execute-a-bash-function-using-sudo
# function() testecho{ echo $1; }
# TEST=$(declare -f testecho)
# sudo -u $SUDO_USER -- bash -c "$TEST; testecho $(whoami)"
#...............................................................................
function linux_main() {
# Set local variables, based on arguments (sourcedir, inifile, force)
local sourcedir="${__si_arg_s}"
local inifile="${__si_arg_i:-$sourcedir/install.ini}"
local force="${__si_arg_f}"
local install_mode missingpkgs
  
  # Check sourcedir is exist and readable, otherwise exit
  check_dir "${sourcedir}" "r"
  check_dir "${sourcedir}/lib" "e"
  check_dir "${sourcedir}/locale" "e"
  
  # Check inifile is exist and readable, if not goto simple-mode, or exit, based on install_mode
  __si_arg_m=$(tr [:upper:] [:lower:] <<< "${__si_arg_m}")
  install_mode=$(check_inifile "${__si_arg_m}")
  [[ "${install_mode}" =~ "simple" ]] && [["${si_arg_m}" != "simple" ]] && notice "$(gettext "Switch to simple mode")"
  
  # Install or check dependency
  if [[ "${__si_arg_c:?}" = "0" ]] ; then
    __si_arg_t=$(sed "s|~|$HOME|g" <<< "${__si_arg_t:-}") # Workaround for such cases: "~/path/to/file"
    __si_arg_t=$(tr [:upper:] [:lower:] <<< "${__si_arg_t}")
    
    # Set targetdir and localedir (targetdir, profiletext, localedir)
    if [[ "${__si_arg_t}" =~ ^sys(tem)?(-wide)? ]]; then
      targetdir=$([[ $EUID = 0 ]] && echo "/usr/local/bin" || echo "${__si_user_home}/.local/bin")
      targetdirtext=$([[ $EUID = 0 ]] || echo "\$HOME/.local/bin")
      localedir=$([[ $EUID = 0 ]] && echo "/usr/local/share/locale" || echo "${__si_user_home}/.local/share/locale")
    elif [[ "${__si_arg_t}" =~ ^us(e)?r(-wide)?$ ]]; then
      targetdir="${__si_user_home}/.local/bin"
      targetdirtext="\$HOME/.local/bin"
      localedir="${__si_user_home}/.local/share/locale"
    else
      targetdir="${__si_arg_t}"
      targetdirtext=$(sed "s|$__si_user_home|\$HOME|g" <<< "${__si_arg_t}")
      localedir="${__si_arg_t}"
    fi
    
    # Check targedir is exists and writable, otherwise exit
    check_dir "${targetdir}" "w"
    [[ -e "${sourcedir}/lib" ]] && check_dir "${targetdir}/lib" "w"
    [[ -e "${sourcedir}/locale" ]] && check_dir "${localedir}" "w"
    
    if [[ "${install_mode}" =~ ^configured$ ]]; then

      # Read initial values based on ini-file
      local dependencies=$( os_ini_val "${inifile}" "install.dependencies" )
      local libraries=$( os_ini_val "${inifile}" "install.libraries" )
      local payloads=$( os_ini_val "${inifile}" "install.payloads" )
      local preinst=$( os_ini_val "${inifile}" "install.preinst" )
      local postinst=$( os_ini_val "${inifile}" "install.postinst" )
      local scripts=$( os_ini_val "${inifile}" "install.scripts" )
      local thirdparties=$( os_ini_val "${inifile}" "install.thirdparties" )

      # Check initial values is accessible, otherwise exit
      check_files "${libraries}" "${sourcedir}/lib"
      check_files "${payloads}" "${sourcedir}"
      check_files "${preinst}" "${sourcedir}" "x"
      check_files "${postinst}" "${sourcedir}" "x"
      check_files "${scripts}" "${sourcedir}" "x"
      check_files "${thirdparties}" "${sourcedir}" "x"
      
      # Run preinstall scripts
      run_scripts "${preinst}" "${sourcedir}"
  
      # Install dependencies
      missingpkgs=$(check_pkgs "${dependencies}")
      if [[ -n "${missingpkgs}" ]]; then 
        debug "$(eval_gettext "Missing dependencies: \${missingpkgs}")"
        install_dependencies "${missingpkgs}" "${force}" || emergency "$(gettext "Installation unsuccessful: there was an error during installing dependencies")"
      fi

      # Run thirdparty dependencies
      run_scripts "${thirdparties}" "${sourcedir}"

      # Install scripts to targetdir
      install_files "${scripts}" "${sourcedir}" "${targetdir}"
      install_files "${libraries}" "${sourcedir}/lib" "${targetdir}/lib"
      # Install locale to localedir
      install_files "locale" "${sourcedir}" "${localedir}"
      install_files "${payloads}" "${sourcedir}" "${targetdir}"

      # Run postinstall scripts
      run_scripts "${postinst}" "${sourcedir}"

    fi
#--------------
# 05. Check targetdir, targetdir/lib, localedir is exists and writable, if not trying to create them, if fails exit !! as USER in user install
   
#    # root
#    if [[ $EUID = 0 ]] && [[ "$SUDO_USER+x" ]] && [[ "${targetdir}" = "${__si_user_home}"* ]]; then # sudo and user-wide install
#      # run install_files as SUDO_USER
#      #sudo -u "$SUDO_USER" -- "install_files ${sourcedir} ${inifile} ${targetdir} ${localedir} ${force}"
#      sudo -u "$SUDO_USER" -- $0 -s "${sourcedir}" -t "${targetdir}" -i "${inifile}"
#    else
#      # install_files as USER/ROOT
#      install_files "${sourcedir}" "${inifile}" "${targetdir}" "${localedir}" "${force}"
#    fi
#
#    # Edit ~/.profile file
#    edit_profile "${targetdirtext}" && source "${__si_user_home}/.profile" && export PATH
 
  else
     # Check dependencies
     check_dependencies "${sourcedir}" "${inifile}"
  fi

}

function_untested_main(){
  debug "$(gettext "Untested operating system. Installation is not possible.")"

  # exit 1
  display_info "$(gettext "Untested operating system. Only manual installtion is possible.")" "$(gettext "Install script manually: 
  * Copy the script and the lib folder to your PATH.
  * Copy to locale folder to your locale folder.
  * Install dependencies.")"
}

function unknown_main(){
  debug "$(gettext "Unsupported operating system. Installation is not possible.")"
  # exit 1
  emergency "$(gettext "Unsupported operating system. Installation is not possible.")"
}
#===============================================================================
# Main section
#===============================================================================

#-------------------------------------------------------------------------------
# Parse usage string
#-------------------------------------------------------------------------------
while read -r __si_tmp_line; do
  if [[ "${__si_tmp_line}" =~ ^- ]]; then
    # fetch single character version of option string
    __si_tmp_opt="${__si_tmp_line%% *}"
    __si_tmp_opt="${__si_tmp_opt:1}"

    # fetch long version if present
    __si_tmp_long_opt=""

    if [[ "${__si_tmp_line}" = *"--"* ]]; then
      __si_tmp_long_opt="${__si_tmp_line#*--}"
      __si_tmp_long_opt="${__si_tmp_long_opt%% *}"
    fi

    # map opt long name to+from opt short name
    printf -v "__si_tmp_opt_long2short_${__si_tmp_long_opt//-/_}" '%s' "${__si_tmp_opt}"
    printf -v "__si_tmp_opt_short2long_${__si_tmp_opt}" '%s' "${__si_tmp_long_opt//-/_}"

    # check if option takes an argument
    if [[ "${__si_tmp_line}" =~ \[.*\] ]]; then
      __si_tmp_opt="${__si_tmp_opt}:" # add : if opt has arg
      __si_tmp_init=""  # it has an arg. init with ""
      printf -v "__si_tmp_has_arg_${__si_tmp_opt:0:1}" '%s' "1"
    elif [[ "${__si_tmp_line}" =~ \{.*\} ]]; then
      __si_tmp_opt="${__si_tmp_opt}:" # add : if opt has arg
      __si_tmp_init=""  # it has an arg. init with ""
      # remember that this option requires an argument
      printf -v "__si_tmp_has_arg_${__si_tmp_opt:0:1}" '%s' "2"
    else
      __si_tmp_init="0" # it's a flag. init with 0
      printf -v "__si_tmp_has_arg_${__si_tmp_opt:0:1}" '%s' "0"
    fi
    __si_tmp_opts="${__si_tmp_opts:-}${__si_tmp_opt}"
  fi

  [[ "${__si_tmp_opt:-}" ]] || continue

  if [[ "${__si_tmp_line}" =~ ^"${__si_defaulttext}"= ]] || [[ "${__si_tmp_line}" =~ \.\ *"${__si_defaulttext}"= ]]; then
    __si_tmp_default="1"
    __si_tmp_defaulttext="${__si_defaulttext}"
  elif [[ "${__si_tmp_line}" =~ ^Default= ]] || [[ "${__si_tmp_line}" =~ \.\ *Default= ]]; then
    __si_tmp_default="1"
    __si_tmp_defaulttext=Default
  else
    [[ ${__si_tmp_default+x} ]] && unset __si_tmp_default
    [[ ${__si_tmp_defaulttext+x} ]] && unset __si_tmp_defaulttext
  fi

  if [[ ${__si_tmp_default:-} = "1" ]]; then
    # ignore default value if option does not have an argument
    __si_tmp_varname="__si_tmp_has_arg_${__si_tmp_opt:0:1}"

    if [[ "${!__si_tmp_varname}" != "0" ]]; then
      __si_tmp_init="${__si_tmp_line##*${__si_tmp_defaulttext}=}"
      __si_tmp_re='^"(.*)"$'
      if [[ "${__si_tmp_init}" =~ ${__si_tmp_re} ]]; then
        __si_tmp_init="${BASH_REMATCH[1]}"
      else
        __si_tmp_re="^'(.*)'$"
        if [[ "${__si_tmp_init}" =~ ${__si_tmp_re} ]]; then
          __si_tmp_init="${BASH_REMATCH[1]}"
        fi
      fi
    fi 
  fi

  if [[ "${__si_tmp_line}" =~ ^"${__si_requiredtext}"\. ]] || [[ "${__si_tmp_line}" =~ \.\ *"${__si_requiredtext}"\. ]] || [[ "${__si_tmp_line}" =~ ^Required\. ]] || [[ "${__si_tmp_line}" =~ \.\ *Required\. ]]; then
    # remember that this option requires an argument
    printf -v "__si_tmp_has_arg_${__si_tmp_opt:0:1}" '%s' "2"
  fi

  printf -v "__si_arg_${__si_tmp_opt:0:1}" '%s' "${__si_tmp_init}"
done <<< "${__si_usage:-}"

#-------------------------------------------------------------------------------
# Parse command-line arguments
#-------------------------------------------------------------------------------
# run getopts only if options were specified in __usage
if [[ "${__si_tmp_opts:-}" ]]; then
  # Allow long options like --this
  __si_tmp_opts="${__si_tmp_opts}-:"

  # Reset in case getopts has been used previously in the shell.
  OPTIND=1

  # start parsing command line
  set +o nounset # unexpected arguments will cause unbound variables
                 # to be dereferenced
  # Overwrite $arg_<flag> defaults with the actual CLI options
  while getopts "${__si_tmp_opts}" __si_tmp_opt; do
    [[ "${__si_tmp_opt}" = "?" ]] && (__si_tmp_params="${*}"; display_info "$(eval_gettext "Invalid use of script: \${__si_tmp_params}")" "\${__si_usage}" "\${__si_helptext}")

    if [[ "${__si_tmp_opt}" = "-" ]]; then
      # OPTARG is long-option-name or long-option=value
      if [[ "${OPTARG}" =~ .*=.* ]]; then
        # --key=value format
        __si_tmp_long_opt=${OPTARG/=*/}
        # Set opt to the short option corresponding to the long option
        __si_tmp_varname="__si_tmp_opt_long2short_${__si_tmp_long_opt//-/_}"
        printf -v "__si_tmp_opt" '%s' "${!__si_tmp_varname}"
        OPTARG=${OPTARG#*=}
      else
        # --key value format
        # Map long name to short version of option
        __si_tmp_varname="__si_tmp_opt_long2short_${OPTARG//-/_}"
        printf -v "__si_tmp_opt" '%s' "${!__si_tmp_varname}"
        # Only assign OPTARG if option takes an argument
        __si_tmp_varname="__si_tmp_has_arg_${__si_tmp_opt}"
        printf -v "OPTARG" '%s' "${@:OPTIND:${!__si_tmp_varname}}"
        # shift over the argument if argument is expected
        ((OPTIND+=__si_tmp_has_arg_${__si_tmp_opt}))
      fi
      # we have set opt/OPTARG to the short value and the argument as OPTARG if it exists
    fi
    __si_tmp_varname="__si_arg_${__si_tmp_opt:0:1}"
    __si_tmp_default="${!__si_tmp_varname}"

    __si_tmp_value="${OPTARG}"
    if [[ -z "${OPTARG}" ]]; then
      __si_tmp_value=$((__si_tmp_default + 1))
    fi

    printf -v "${__si_tmp_varname}" '%s' "${__si_tmp_value}"
    debug "cli arg ${__si_tmp_varname} = (${__si_tmp_default}) -> ${!__si_tmp_varname}"
  done
  set -o nounset # no more unbound variable references expected

  shift $((OPTIND-1))

  if [[ "${1:-}" = "--" ]] ; then
    shift
  fi
fi

#-------------------------------------------------------------------------------
# Helper functions
#-------------------------------------------------------------------------------
if [[ "${__si_arg_h:?}" = "1" ]]; then
  # Help exists with code 1
  display_info "$(eval_gettext "Help using \${__si_base}")" "${__si_usage}" "${__si_helptext}"
fi

if [[ "${__si_arg_V:?}" = "1" ]]; then
  # Version exists with code 1
  display_info "${__si_name}" "${__si_version}" "${__si_license}"
fi

#-------------------------------------------------------------------------------
# Validate required arguments
#-------------------------------------------------------------------------------
[[ "${LOG_LEVEL:-}" ]] || emergency "$(gettext "Cannot continue without LOG_LEVEL.")"

#-------------------------------------------------------------------------------
# Validate required option arguments
#-------------------------------------------------------------------------------
for __si_tmp_varname in ${!__si_tmp_has_arg_*}; do
  # validate only options which required an argument
  [[ "${!__si_tmp_varname}" = "2" ]] || continue

  __si_tmp_opt_short="${__si_tmp_varname##*_}"
  __si_tmp_varname="__si_arg_${__si_tmp_opt_short}"
  [[ "${!__si_tmp_varname}" ]] && continue

  __si_tmp_varname="__si_tmp_opt_short2long_${__si_tmp_opt_short}"
  printf -v "__si_tmp_opt_long" '%s' "${!__si_tmp_varname}"
  [[ "${__si_tmp_opt_long:-}" ]] && __si_tmp_opt_long=" (--${__si_tmp_opt_long//_/-})"
  
  __si_tmp_fullopt=${__si_tmp_opt_short}${__si_tmp_opt_long:-}
  display_info "$(eval_gettext "Option -\${__si_tmp_fullopt} requires an argument")" "${__si_usage}" "${__si_helptext}"
done

#-------------------------------------------------------------------------------
# Cleanup temporary variables 
#-------------------------------------------------------------------------------
for __tmp_varname in ${!__si_tmp_*}; do
  unset -v "${__tmp_varname}"
done

unset -v __tmp_varname

#-------------------------------------------------------------------------------
# Externally supplied __si_usage. Nothing else to do here
#-------------------------------------------------------------------------------
if [[ "${__si_external_usage:-}" == 1 ]]; then
  unset -v __si_external_usage
  return
fi

#-------------------------------------------------------------------------------
# Signal trapping and backtracing
#-------------------------------------------------------------------------------
function __si_cleanup_before_exit () {
  info "$(gettext "Cleaning up. Done")"
}
trap __si_cleanup_before_exit EXIT

# requires `set -o errtrace`
__si_err_report() {
  local error_code
  error_code=${?}
  function=${1}
  line=${2}

  error "$(eval_gettext "Error in \${__si_file} in function \${function} on line \${line}")"
  exit ${error_code}
}
# Uncomment the following line for always providing an error backtrace
# trap '__si_err_report "${FUNCNAME:-.}" ${LINENO}' ERR

#-------------------------------------------------------------------------------
# Call internal functions
#-------------------------------------------------------------------------------
# debug mode
if [[ "${__si_arg_d:?}" = "1" ]]; then
  set -o xtrace
  LOG_LEVEL="7"
  # Enable error backtracing
  trap '__si_err_report "${FUNCNAME:-.}" ${LINENO}' ERR
fi

# verbose mode
if [[ "${__si_arg_v:?}" = "1" ]]; then
  set -o verbose
fi

# no color mode
if [[ "${__si_arg_n:?}" = "1" ]]; then
  NO_COLOR="true"
fi

#-------------------------------------------------------------------------------
# Runtime
#-------------------------------------------------------------------------------
if [[ "${__si_srcd:-}" == 0 ]]; then
  
  # Check supported OS, otherwise exit or untested
  if [[ "${__ostype}" = "linux-gnu" ]]; then linux_main;
  elif [[ "${__ostype}" = "unknown" ]] ; then unknown_main;
  else untested_os_main
  fi

fi

#===============================================================================
# END OF FILE
#===============================================================================
